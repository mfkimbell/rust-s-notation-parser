{"message":"unused import: `std::error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":1397,"byte_end":1407,"line_start":32,"line_end":32,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"    use std::error;","highlight_start":9,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1393,"byte_end":1408,"line_start":32,"line_end":32,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"    use std::error;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::error`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:32:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use std::error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unreachable expression","code":{"code":"unreachable_code","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":19533,"byte_end":19559,"line_start":548,"line_end":548,"column_start":13,"column_end":39,"is_primary":true,"text":[{"text":"            std::rc::Rc::new(ErrorExp)","highlight_start":13,"highlight_end":39}],"label":"unreachable expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":11712,"byte_end":19520,"line_start":379,"line_end":547,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match nexttok {","highlight_start":13,"highlight_end":28},{"text":"                \"+\" => {","highlight_start":1,"highlight_end":25},{"text":"                    expect(toks, nexttok); // This should remove the \"+\" from the front of toks","highlight_start":1,"highlight_end":96},{"text":"                    let arg1 = parse_exp(toks); // We recursively parse the first arg of \"+\"","highlight_start":1,"highlight_end":93},{"text":"                    let arg2 = parse_exp(toks); // and the same recursive parse of the second arg of \"+\"\"","highlight_start":1,"highlight_end":106},{"text":"                    return std::rc::Rc::new(PlusExp {","highlight_start":1,"highlight_end":54},{"text":"                        lhs: arg1,","highlight_start":1,"highlight_end":35},{"text":"                        rhs: arg2,","highlight_start":1,"highlight_end":35},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                \"-\" => {","highlight_start":1,"highlight_end":25},{"text":"                    expect(toks, nexttok);","highlight_start":1,"highlight_end":43},{"text":"                    let arg1 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    let arg2 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    return std::rc::Rc::new(MinusExp {","highlight_start":1,"highlight_end":55},{"text":"                        lhs: arg1,","highlight_start":1,"highlight_end":35},{"text":"                        rhs: arg2,","highlight_start":1,"highlight_end":35},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                \"*\" => {","highlight_start":1,"highlight_end":25},{"text":"                    expect(toks, nexttok);","highlight_start":1,"highlight_end":43},{"text":"                    let arg1 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    let arg2 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    return std::rc::Rc::new(MultExp {","highlight_start":1,"highlight_end":54},{"text":"                        lhs: arg1,","highlight_start":1,"highlight_end":35},{"text":"                        rhs: arg2,","highlight_start":1,"highlight_end":35},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // ^ 2 3 4","highlight_start":1,"highlight_end":27},{"text":"                \"^\" => {","highlight_start":1,"highlight_end":25},{"text":"                    expect(toks, nexttok);","highlight_start":1,"highlight_end":43},{"text":"                    let arg1 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    let arg2 = parse_exp(toks);","highlight_start":1,"highlight_end":48},{"text":"                    return std::rc::Rc::new(PowExp {","highlight_start":1,"highlight_end":53},{"text":"                        lhs: arg1,","highlight_start":1,"highlight_end":35},{"text":"                        rhs: arg2,","highlight_start":1,"highlight_end":35},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // + 1 (2) wrong","highlight_start":1,"highlight_end":33},{"text":"                // + 1 (-2) fine","highlight_start":1,"highlight_end":33},{"text":"                // + 1 (+1) fine","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // + 1 ( + 1 (+ 1 2))","highlight_start":1,"highlight_end":38},{"text":"                \"(\" => {","highlight_start":1,"highlight_end":25},{"text":"                    expect(toks, nexttok);","highlight_start":1,"highlight_end":43},{"text":"                    let op = toks[0];","highlight_start":1,"highlight_end":38},{"text":"                    if ops.is_match(op) {","highlight_start":1,"highlight_end":42},{"text":"                        // The item right after a paren should be an operator","highlight_start":1,"highlight_end":78},{"text":"                        expect(toks, op);","highlight_start":1,"highlight_end":42},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        return std::rc::Rc::new(ErrorExp); // Return an error if not","highlight_start":1,"highlight_end":85},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut next = peek(toks, 0); // This will not remove the item at the front of toks","highlight_start":1,"highlight_end":104},{"text":"                    let mut args: Vec<std::rc::Rc<dyn Exp>> = vec![]; // A vector to hold args within the parens","highlight_start":1,"highlight_end":113},{"text":"                    while next != \")\" {","highlight_start":1,"highlight_end":40},{"text":"                        // Add the args until we see a right hand paren","highlight_start":1,"highlight_end":72},{"text":"                        let next_arg = parse_exp(toks);","highlight_start":1,"highlight_end":56},{"text":"                        args.push(next_arg);","highlight_start":1,"highlight_end":45},{"text":"                        next = peek(toks, 0);","highlight_start":1,"highlight_end":46},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    expect(toks, \")\");","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    if args.len() == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        return std::rc::Rc::new(ErrorExp);","highlight_start":1,"highlight_end":59},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    match op {","highlight_start":1,"highlight_end":31},{"text":"                        \"+\" => {","highlight_start":1,"highlight_end":33},{"text":"                            if args.len() == 1 {","highlight_start":1,"highlight_end":49},{"text":"                                // Addition allows for unary addition, thus we can use 0 for the left hand side.","highlight_start":1,"highlight_end":113},{"text":"                                // (+ 1) -> (+ 1 0)","highlight_start":1,"highlight_end":52},{"text":"                                return std::rc::Rc::new(PlusExp {","highlight_start":1,"highlight_end":66},{"text":"                                    lhs: std::rc::Rc::new(LitExp { n: 0 }),","highlight_start":1,"highlight_end":76},{"text":"                                    rhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":71},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            // For binary or more arguments, we use the arg 0 as our left hand side number and arg 1 as our right hand arg.","highlight_start":1,"highlight_end":140},{"text":"                            // (+ 1 2) -> args[0] = 1 and args[1] = 2","highlight_start":1,"highlight_end":70},{"text":"                            let mut ast = std::rc::Rc::new(PlusExp {","highlight_start":1,"highlight_end":69},{"text":"                                lhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":67},{"text":"                                rhs: std::rc::Rc::clone(&args[1]),","highlight_start":1,"highlight_end":67},{"text":"                            });","highlight_start":1,"highlight_end":32},{"text":"                            for arg in &args[2..args.len()] {","highlight_start":1,"highlight_end":62},{"text":"                                ast = std::rc::Rc::new(PlusExp {","highlight_start":1,"highlight_end":65},{"text":"                                    lhs: ast, // Since we only allow for binary ASTs, we only allow for binary additions, thus our left hand side would be our previously calculated addition. In this case (+ (+ 1 2) 3) would return the AST you parsed for (+ 1 2)","highlight_start":1,"highlight_end":262},{"text":"                                    rhs: arg.to_owned(),","highlight_start":1,"highlight_end":57},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            return ast;","highlight_start":1,"highlight_end":40},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        \"-\" => {","highlight_start":1,"highlight_end":33},{"text":"                            if args.len() == 1 {","highlight_start":1,"highlight_end":49},{"text":"                                return std::rc::Rc::new(MinusExp {","highlight_start":1,"highlight_end":67},{"text":"                                    lhs: std::rc::Rc::new(LitExp { n: 0 }),","highlight_start":1,"highlight_end":76},{"text":"                                    rhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":71},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let mut ast = std::rc::Rc::new(MinusExp {","highlight_start":1,"highlight_end":70},{"text":"                                lhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":67},{"text":"                                rhs: std::rc::Rc::clone(&args[1]),","highlight_start":1,"highlight_end":67},{"text":"                            });","highlight_start":1,"highlight_end":32},{"text":"                            for arg in &args[2..args.len()] {","highlight_start":1,"highlight_end":62},{"text":"                                ast = std::rc::Rc::new(MinusExp {","highlight_start":1,"highlight_end":66},{"text":"                                    lhs: ast,","highlight_start":1,"highlight_end":46},{"text":"                                    rhs: arg.to_owned(),","highlight_start":1,"highlight_end":57},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            return ast;","highlight_start":1,"highlight_end":40},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        \"*\" => {","highlight_start":1,"highlight_end":33},{"text":"                            if args.len() == 1 {","highlight_start":1,"highlight_end":49},{"text":"                                return std::rc::Rc::new(MultExp {","highlight_start":1,"highlight_end":66},{"text":"                                    lhs: std::rc::Rc::new(LitExp { n: 0 }),","highlight_start":1,"highlight_end":76},{"text":"                                    rhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":71},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let mut ast = std::rc::Rc::new(MultExp {","highlight_start":1,"highlight_end":69},{"text":"                                lhs: std::rc::Rc::clone(&args[0]),","highlight_start":1,"highlight_end":67},{"text":"                                rhs: std::rc::Rc::clone(&args[1]),","highlight_start":1,"highlight_end":67},{"text":"                            });","highlight_start":1,"highlight_end":32},{"text":"                            for arg in &args[2..args.len()] {","highlight_start":1,"highlight_end":62},{"text":"                                ast = std::rc::Rc::new(MultExp {","highlight_start":1,"highlight_end":65},{"text":"                                    lhs: ast,","highlight_start":1,"highlight_end":46},{"text":"                                    rhs: arg.to_owned(),","highlight_start":1,"highlight_end":57},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            return ast;","highlight_start":1,"highlight_end":40},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                      ","highlight_start":1,"highlight_end":23},{"text":"                        \"^\" => {","highlight_start":1,"highlight_end":33},{"text":"                            if args.len() == 1 {","highlight_start":1,"highlight_end":49},{"text":"                                return std::rc::Rc::new(ErrorExp);","highlight_start":1,"highlight_end":67},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            let mut ast = std::rc::Rc::new(PowExp {","highlight_start":1,"highlight_end":68},{"text":"                                lhs: std::rc::Rc::clone(&args[args.len() - 2]),","highlight_start":1,"highlight_end":80},{"text":"                                rhs: std::rc::Rc::clone(&args[args.len() - 1]),","highlight_start":1,"highlight_end":80},{"text":"                            });","highlight_start":1,"highlight_end":32},{"text":"                            for arg in &args[..args.len() - 2] {","highlight_start":1,"highlight_end":65},{"text":"                                ast = std::rc::Rc::new(PowExp {","highlight_start":1,"highlight_end":64},{"text":"                                    lhs: std::rc::Rc::clone(arg),","highlight_start":1,"highlight_end":66},{"text":"                                    rhs: ast,","highlight_start":1,"highlight_end":46},{"text":"                                });","highlight_start":1,"highlight_end":36},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            return ast;","highlight_start":1,"highlight_end":40},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        _ => {","highlight_start":1,"highlight_end":31},{"text":"                            expect(toks, nexttok);","highlight_start":1,"highlight_end":51},{"text":"                            return std::rc::Rc::new(LitExp {","highlight_start":1,"highlight_end":61},{"text":"                                n: nexttok.parse().unwrap(),","highlight_start":1,"highlight_end":61},{"text":"                            });","highlight_start":1,"highlight_end":32},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // TODO: complete this match case","highlight_start":1,"highlight_end":54},{"text":"                    // Consider the possibility that you don't match on an op such as \"+\" above and you don't see an open paren","highlight_start":1,"highlight_end":128},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let val = toks[0];","highlight_start":1,"highlight_end":39},{"text":"                    expect(toks, nexttok);","highlight_start":1,"highlight_end":43},{"text":"                    return std::rc::Rc::new(LitExp {","highlight_start":1,"highlight_end":53},{"text":"                        n: val.parse().unwrap(),","highlight_start":1,"highlight_end":49},{"text":"                    });","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"any code following this `match` expression is unreachable, as all arms diverge","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_code)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unreachable expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:548:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m379\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match nexttok {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m380\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"+\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m381\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    expect(toks, nexttok); // This should remove the \"+\" from the front of toks\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m382\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let arg1 = parse_exp(toks); // We recursively parse the first arg of \"+\"\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m546\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m547\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12many code following this `match` expression is unreachable, as all arms diverge\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m548\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            std::rc::Rc::new(ErrorExp)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munreachable expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unreachable_code)]` on by default\u001b[0m\n\n"}
{"message":"2 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 2 warnings emitted\u001b[0m\n\n"}
